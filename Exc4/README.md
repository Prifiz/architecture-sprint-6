# Описание решения по ОСАГО

## Требуется ли osago-aggregator своё хранилище данных?

Требуется, для хранения отправленных заявок и полученных по ним решений от страховых. Это позволит не нагружать core-app апдейтами при опросе каждого следующего предложения от очередной страховой (количество которых будет расти), а отправлять накопленные данные по готовности

## Интеграция core-app и osago-aggregator

У core-app должна быть высокая пропускная способность по части заявок на ОСАГО. Синхронно ждать ответы по 60 секунд (а то и более) не можем. Поэтому логичнее оставить сообщение в брокере для osago-aggregator, который будет по мере поступления заявок запрашивать данные от страховых. Накопленные данные публикуются в топик для ответа с использованием паттерна transactional outbox для обеспечения целостности данных.

Брокер - Kafka. Высокая пропускная способность, порядок не особо важен, постоянно нарастающая нагрузка.

## API для веб-приложения в core-app

Server Push на базе GraphQL Subscriptions т.к. с одной стороны необходимо обеспечить высокую пропускную способность (при большом наплыве клиентом не можем синхронно ждать), но при этом нужно оповестить клиента о получении ответа с предложениями страховых. Вебсокеты и SSE имеют существенные ограничения по кол-ву соединений или по security, поэтому не подойдут.

## Применение паттернов отказоустойчивости

### Rate Limiting
Предлагаю применить для core-app в части запросов со стороны Web-приложения. К нему обращаются и другие сервисы, поэтому в пике нагрузки его замедление может пойти по цепочке. А для ОСАГО по условиям имеем высокую нагрузку по RPS, что сильно осложнит монолиту жизнь

### Retry и Timeout
Предлагаю применить в osago-aggregator при обращении в страховые.
Поскольку мы не контролируем эти источники данных и состояние внешней сети на пути к ним, то запросы могут с одной стороны быть прерваны по различным причинам (недоступность сервисов, тот же circuit breaker на стороне страховых и т.п.) - и тут необходимо попытаться запросить снова. А с другой стороны опять же по не зависящим от нас причинам запрос может выполняться слишком долго, что отсрочит агрегацию результатов и предоставление клиенту предложений от других страховых. Поэтому в случае слишком продолжительного времени запроса проще его отсечь и отправить в core-app то, что уже удалось собрать. В совокупности с Retry это даст необходимый уровень надежности.